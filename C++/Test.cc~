#include "BinTree.h"
#include <iostream>


int main() {

  //------------------------------------------------------------------------------------------------------------------
  // Creating a tree (of type int-int) and populating it with the "standard" keys (value is 42 for all the nodes)
  //------------------------------------------------------------------------------------------------------------------

  BinTree<int,int> b1{};

  b1.insert({8, 42});
  b1.insert({3, 42});
  b1.insert({10, 42});
  b1.insert({1, 42});
  b1.insert({6, 42});
  b1.insert({7, 42});
  b1.insert({14, 42});
  b1.insert({13, 42});
  b1.insert({4, 42});

  //--------------------------------
  // Printing the tree
  //--------------------------------

  std::cout << b1 << std::endl;

  //-------------------------------
  // Size of the tree
  //-------------------------------

  std::cout << "Size of the tree is:\t" << b1.size() << std::endl;
  
  //--------------------------------
  // Inserting an existing key
  //--------------------------------

  b1.insert({3, 84});

  //--------------------------------
  // Balancing the tree
  //--------------------------------

  b1.balance();

  //------------------------------------------------
  // Checking the size of the tree after balance
  //------------------------------------------------

  std::cout << "Size of the tree after balance is:\t" << b1.size() << std::endl;


  //-----------------------------------------------
  // Find function
  //-----------------------------------------------

  b1.find(7);
  b1.find(16);
  b1.find(43);

  //----------------------------------------------
  // [] operator
  //----------------------------------------------

  std::cout << b1[14] <<"\n" << b1[25] <<std::endl;

  
  //-------------------------------
  // Copy constructor
  //-------------------------------

  BinTree<int, int> copy_c{b1};

  std::cout << "Printing the original tree:\n" << b1 << "\n";
  std::cout << "Printing the tree created using copy ctor:\n" << copy_c << std::endl;

  
  //----------------------------------
  // Copy assignment
  //----------------------------------

  BinTree<int, int> copy_a;

  copy_a = b1;

  std::cout << "Printing the copied tree:\n" <<copy_a << std::endl;

  
  //---------------------------------
  // Move constructor
  //---------------------------------

  BinTree<int,int> move_c{std::move(copy_c)};

  std::cout << "Printing the tree created using move ctor:\n" << move_c << std::endl;

  //---------------------------------
  // Move assignment
  //---------------------------------

  BinTree<int,int> move_a;

  move_a = std::move(copy_a);

  std::cout << "Printing the tree for which we used move assignment:\n" << move_a << std::endl;


  //----------------------------------------
  // Clearing the tree
  //----------------------------------------

  b1.clear();

  std::cout << "Size of the tree after clear is:\t" << b1.size() << std::endl;


  return 0;
}

/*

  //iterate through the tree with Iterator
  for(auto it=bst_int.begin(); it != bst_int.end(); it++){
    std::cout<<"Key: "<<it->first<<",  Value: "<<it->second<<std::endl;
  }
  //iterate through the tree with ConstIterator
  for(auto cit=bst_int.cbegin(); cit != bst_int.cend(); cit++){
    std::cout<<"Key: "<<cit->first<<",  Value: "<<cit->second<<std::endl;
    //cit->second = 2; //---> try to modify through const iterator
  }
  //operator overloading []
  std::cout << "Look for existing key bst_int[8]= " <<bst_int[8] <<std::endl;
  std::cout << "Look for not existing key bst_int[55]= " << bst_int[55]<<std::endl;
  //find
  std::cout<<"Find() with exisiting key: "<<bst_int.find(55)->second<<std::endl;
  if(bst_int.find(999) != bst_int.end()) std::cout<<"key found."<<std::endl;
  else std::cout<<"Find() with no exisiting key - key not found"<<std::endl;


  BST<int,int> bst_int_copy;
  //copy assignment
  bst_int_copy = bst_int;
  std::cout << "Print the copied tree\n" << bst_int_copy << std::endl;
  bst_int.add(120,30);
  //after adding an element to the first tree the second does not change
  std::cout << "Print the tree" << bst_int << std::endl;
  std::cout << "Print the copied tree" << bst_int_copy << std::endl;

  //copy constructor
  BST<int,int> bst_int_copy_constr = bst_int;
  std::cout << "Print the tree constructed usign copy construct" << bst_int_copy_constr << std::endl;
  bst_int.add(130,20);
  //after adding an element to the first tree the second does not change
  std::cout << "Print the bst" << bst_int << std::endl;
  std::cout << "Print the constructed tree" << bst_int_copy_constr << std::endl;

  //move assignment
  BST<int,int> bst_int_move;
  bst_int_move = std::move(bst_int_copy_constr);
  std::cout << "Print the moved tree" << bst_int_move << std::endl;

  //move constructor
  BST<int,int> bst_int_move_constr = std::move(bst_int_copy);
  std::cout << "Print the moved constructor tree" << bst_int_move << std::endl;

  bst_int.clear();
  std::cout<<bst_int<<std::endl;
  bst_int.clear();


*/
